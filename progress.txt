## 2026-01-25 - US-001: Setup progetto Next.js

### What was done:
- Initialized Next.js 16.1.4 project with App Router
- Configured TypeScript 5
- Configured Tailwind CSS 4
- Created folder structure: app/, components/, lib/, types/
- Added npm scripts: typecheck, test
- Typecheck passes successfully

### Files created/modified:
- package.json (renamed to "riassumi", added typecheck and test scripts)
- app/ (layout.tsx, page.tsx, globals.css, favicon.ico)
- components/.gitkeep
- lib/.gitkeep
- types/.gitkeep
- tsconfig.json
- next.config.ts
- postcss.config.mjs
- eslint.config.mjs
- .gitignore

### Notes for next developer:
- The project is ready for feature development
- Next priority is US-002: Setup Prisma with base schema
- Run `npm run dev` to start development server
- Run `npm run typecheck` to check types

---

## 2026-01-25 - US-002: Setup Prisma con schema base

### What was done:
- Installed Prisma 7.3.0 and @prisma/client
- Configured SQLite with better-sqlite3 adapter (required for Prisma 7)
- Created all database models:
  - User: id, email, password_hash, created_at, summaries relation
  - Summary: id, user_id (nullable), title, content, detail_level, pdf_name, created_at, quizzes relation
  - Quiz: id, summary_id, questions (JSON as string), created_at
  - ApiKey: id, key_encrypted, provider, is_active, last_used, fail_count, disabled_until
- Ran initial migration successfully
- Generated Prisma client to lib/generated/prisma/
- Created lib/prisma.ts singleton for database access
- Typecheck passes successfully

### Files created/modified:
- package.json (added prisma, @prisma/client, @prisma/adapter-better-sqlite3, better-sqlite3, dotenv)
- prisma/schema.prisma (database schema)
- prisma/migrations/20260125113815_init/migration.sql (initial migration)
- prisma/dev.db (SQLite database file)
- prisma.config.ts (Prisma configuration)
- lib/prisma.ts (Prisma client singleton)
- lib/generated/prisma/ (generated Prisma client)
- .env (DATABASE_URL configuration)

### Notes for next developer:
- Use `import { prisma } from '@/lib/prisma'` to access the database
- Prisma 7 uses a new configuration approach - see prisma.config.ts
- The SQLite database file is at prisma/dev.db
- Run `npx prisma studio` to view/edit data
- Run `npx prisma migrate dev` to apply schema changes
- Next priority is US-003: Servizio gestione API key con failover

---

## 2026-01-25 - US-003: Servizio gestione API key con failover

### What was done:
- Created lib/api-keys.ts with complete API key management service
- Implemented AES-256-GCM encryption/decryption for secure key storage
- Functions implemented:
  - `encryptKey(plainKey)` - Encrypts API key with AES-256-GCM
  - `decryptKey(encryptedData)` - Decrypts stored API key
  - `getActiveKey()` - Returns first active, non-disabled key (decrypted)
  - `getActiveKeyWithId()` - Returns key with ID for tracking success/failure
  - `markKeyFailed(keyId)` - Increments fail_count, disables for 1 hour if > 5 failures
  - `markKeySuccess(keyId)` - Resets fail_count and clears disabled_until
  - `addApiKey(plainKey, provider)` - Adds new encrypted API key to database
  - `deactivateKey(keyId)` - Soft deletes a key
  - `reactivateKey(keyId)` - Reactivates a disabled/deactivated key
- Encryption key is read from ENCRYPTION_KEY environment variable
- Added ENCRYPTION_KEY to .env file (with placeholder value)
- Typecheck passes successfully

### Files created/modified:
- lib/api-keys.ts (new - API key management service)
- .env (added ENCRYPTION_KEY variable)

### Notes for next developer:
- Import API key functions: `import { getActiveKey, markKeyFailed, markKeySuccess } from '@/lib/api-keys'`
- For failover pattern: use `getActiveKeyWithId()`, then `markKeyFailed(id)` or `markKeySuccess(id)`
- Keys are automatically load-balanced (least recently used first)
- IMPORTANT: Change ENCRYPTION_KEY in production to a strong random value
- Use `addApiKey(key, 'openrouter')` to add new API keys to the database
- Next priority is US-004: Componenti UI base

---

## 2026-01-25 - US-004: Componenti UI base

### What was done:
- Created components/ui/ directory with reusable UI components
- Created Button component with 3 variants: primary, secondary, ghost
- Created Card component with CardHeader, CardContent, CardFooter subcomponents
- Created Input component with label and error state support
- Created Select component with label, error state, and custom dropdown arrow
- Created Spinner component with sm/md/lg size variants
- Created index.tsx for easy component imports
- All components use Tailwind CSS for styling
- All components typed with TypeScript and use forwardRef for ref forwarding
- Supports dark mode via Tailwind dark: variants
- Typecheck passes successfully

### Files created/modified:
- components/ui/button.tsx (new - Button with primary/secondary/ghost variants)
- components/ui/card.tsx (new - Card, CardHeader, CardContent, CardFooter)
- components/ui/input.tsx (new - Input with label and error support)
- components/ui/select.tsx (new - Select dropdown with options)
- components/ui/spinner.tsx (new - Loading spinner with size variants)
- components/ui/index.tsx (new - barrel export for all components)

### Notes for next developer:
- Import components: `import { Button, Card, Input, Select, Spinner } from '@/components/ui'`
- Button variants: `<Button variant="primary|secondary|ghost">...</Button>`
- Card example: `<Card><CardHeader>Title</CardHeader><CardContent>Body</CardContent></Card>`
- Input with error: `<Input label="Email" error="Invalid email" />`
- Select usage: `<Select options={[{value: 'a', label: 'A'}]} label="Choose" />`
- Spinner sizes: `<Spinner size="sm|md|lg" />`
- Next priority is US-005: Homepage con hero section

---

## 2026-01-25 - US-005: Homepage con hero section

### What was done:
- Created responsive homepage with hero section
- Hero section features "Riassu.mi" title with accent color on ".mi"
- Added brief description explaining the AI-powered PDF summarization
- CTA button "Carica PDF" links to /upload
- "Come funziona" section with 3 steps: Carica, Riassumi, Quiz
- Each step has an icon, title, and description
- Mobile-first responsive design using Tailwind CSS
- Dark mode support throughout
- Updated app metadata (title and description)
- Added simple footer with copyright
- Typecheck passes successfully

### Files created/modified:
- app/page.tsx (complete rewrite - homepage with hero and steps)
- app/layout.tsx (updated metadata for app branding)

### Notes for next developer:
- Homepage uses the Button component from @/components/ui
- Design uses gradient background from blue-50 to white
- Responsive breakpoints: default (mobile), sm:, md:
- The /upload route is not yet created - that's US-006
- Next priority is US-006: Upload PDF con drag & drop

---

## 2026-01-25 - US-006: Upload PDF con drag & drop

### What was done:
- Created /upload page with file upload functionality
- Created FileUpload component with drag & drop support
- Features implemented:
  - Drag & drop with visual feedback (border color change, background change)
  - Click to select file via hidden input
  - Validation for .pdf extension and application/pdf MIME type
  - 20MB file size limit
  - Displays file name and formatted file size after selection
  - Error messages for invalid files (wrong format, size exceeded)
  - "Rimuovi file" button to clear selection
  - "Genera Riassunto" button appears when file is valid
- Mobile-first responsive design with Tailwind CSS
- Dark mode support throughout
- Back link to homepage
- Typecheck passes successfully

### Files created/modified:
- components/file-upload.tsx (new - FileUpload component with drag & drop)
- app/upload/page.tsx (new - upload page with validation logic)

### Notes for next developer:
- FileUpload is a reusable component: `import { FileUpload } from '@/components/file-upload'`
- MAX_FILE_SIZE constant exported from file-upload.tsx (20MB)
- formatFileSize utility function also exported
- The "Genera Riassunto" button doesn't have functionality yet - that's US-012
- Next priority is US-007: Estrazione testo da PDF

---

## 2026-01-25 - US-007: Estrazione testo da PDF

### What was done:
- Installed pdf-parse 2.4.5 library for PDF text extraction
- Created lib/pdf-parser.ts with complete PDF text extraction functionality
- Functions implemented:
  - `extractText(buffer, excludePages?)` - Main function that returns array of { pageNumber, text }
  - `extractTextWithInfo(buffer, excludePages?)` - Returns pages array plus totalPages count
  - `getPageCount(buffer)` - Gets total page count without extracting text
- Support for excluding specific pages via excludePages parameter (1-indexed array)
- Custom PDFExtractionError class for error handling
- Error handling for:
  - PDFs with no pages
  - All pages excluded
  - PDFs with no extractable text (scanned images, protected content)
- Typecheck passes successfully

### Files created/modified:
- package.json (added pdf-parse, @types/pdf-parse)
- lib/pdf-parser.ts (new - PDF text extraction service)

### Notes for next developer:
- Import functions: `import { extractText, extractTextWithInfo, getPageCount, PDFExtractionError } from '@/lib/pdf-parser'`
- The excludePages parameter is 1-indexed (first page is 1, not 0)
- extractText returns only pages with extracted text; use extractTextWithInfo to also get totalPages
- The pdf-parse library uses pdfjs-dist under the hood and works in Node.js environment
- Next priority is US-008: Input selezione pagine da escludere

---

## 2026-01-25 - US-008: Input selezione pagine da escludere

### What was done:
- Added page exclusion input to the /upload page
- Input accepts format "1-3, 5, 10-15" (ranges and single pages)
- Real-time validation with Italian error messages
- parsePageRanges() function already existed in lib/utils.ts
- Added PDF page count display after file selection
- Preview section showing:
  - "Pagine escluse: X"
  - "Pagine da processare: Y"
  - List of excluded pages (when 20 or fewer)
- Installed pdf-lib for client-side PDF page count extraction
- Validation against max page number from the PDF
- Hides "Genera Riassunto" button if there are validation errors
- Typecheck passes successfully

### Files created/modified:
- package.json (added pdf-lib dependency)
- app/upload/page.tsx (added page exclusion input, state management, validation)

### Notes for next developer:
- The excludePagesInput state holds the raw user input string
- The excludedPages state holds the parsed array of page numbers
- pdf-lib is used for client-side page counting (runs in browser)
- pdf-parse is used server-side for text extraction (runs in Node.js)
- The parsePageRanges function in lib/utils.ts validates and parses the input
- Next priority is US-009: Selector livello dettaglio riassunto

---

## 2026-01-25 - US-009: Selector livello dettaglio riassunto

### What was done:
- Created DetailLevelSelector component in components/detail-level-selector.tsx
- Component displays 3 options with radio-button style cards: Breve, Medio, Dettagliato
- Each option shows its description visibly (better UX than hidden tooltips)
- Descriptions match PRD requirements:
  - Breve: "Bullet points dei concetti chiave"
  - Medio: "1-2 paragrafi per sezione"
  - Dettagliato: "Spiegazioni complete con esempi"
- Default value is "Medio"
- Integrated into /upload page with state management
- Responsive grid layout (stacked on mobile, 3 columns on larger screens)
- Dark mode support with appropriate colors
- Typecheck passes successfully

### Files created/modified:
- components/detail-level-selector.tsx (new - DetailLevelSelector component)
- app/upload/page.tsx (added DetailLevelSelector import and usage)

### Notes for next developer:
- Import the component: `import { DetailLevelSelector, DetailLevel } from '@/components/detail-level-selector'`
- DetailLevel type is "brief" | "medium" | "detailed"
- The detailLevel state will be used in US-010 (OpenRouter service) to select the appropriate prompt
- The selector appears only after a valid PDF file is selected
- Next priority is US-010: Servizio OpenRouter per riassunti

---

## 2026-01-25 - US-010: Servizio OpenRouter per riassunti

### What was done:
- Created lib/openrouter.ts with complete OpenRouter AI integration
- Implemented `generateSummary(text, detailLevel)` function
- Uses free model: meta-llama/llama-3.2-3b-instruct:free
- Created Italian system prompts for each detail level:
  - Brief: bullet points dei concetti chiave
  - Medium: 1-2 paragrafi per sezione
  - Detailed: spiegazioni complete con esempi
- Integrated with API key failover system:
  - Uses `getActiveKeyWithId()` to get key with tracking ID
  - Calls `markKeyFailed(id)` on API errors
  - Calls `markKeySuccess(id)` on successful response
  - Retries up to 3 times with different keys on auth/rate limit errors (401, 429, 402)
- Returns summary in Markdown format
- Created `OpenRouterError` class for error handling with code and status
- Supports SITE_URL environment variable for HTTP-Referer header
- Typecheck passes successfully

### Files created/modified:
- lib/openrouter.ts (new - OpenRouter AI integration service)

### Notes for next developer:
- Import the function: `import { generateSummary, OpenRouterError } from '@/lib/openrouter'`
- The function is async and returns a Promise<string> (Markdown content)
- DetailLevel type is imported from '@/components/detail-level-selector'
- Make sure ENCRYPTION_KEY is set in .env for API key decryption
- API keys must be added to the database first via `addApiKey()` from lib/api-keys.ts
- Optional: Set SITE_URL in .env for proper HTTP-Referer header (defaults to localhost:3000)
- Next priority is US-011: Chunking per PDF lunghi

---

## 2026-01-25 - US-011: Chunking per PDF lunghi

### What was done:
- Added text chunking functionality to lib/openrouter.ts for handling long PDFs
- Created `estimateTokens(text)` function that estimates tokens (~4 chars/token)
- Created `chunkText(text, maxTokens)` function that intelligently splits text:
  - First tries to split at paragraph boundaries (double newlines)
  - Falls back to sentence boundaries if paragraphs are too long
  - Falls back to word boundaries as last resort
  - Default max is 3000 tokens (safe for free models)
- Created `generateSummaryWithChunking(text, detailLevel, maxTokens, onProgress)` function:
  - Automatically detects if text needs chunking
  - Generates summary for each chunk individually
  - Combines partial summaries using AI for coherent output
  - Falls back to concatenated summaries if AI combining fails
  - Supports progress callback for UI updates
- Added `getCombinePrompt()` helper for the combining step
- Exported `ChunkProgressCallback` type for progress tracking
- Typecheck passes successfully

### Files created/modified:
- lib/openrouter.ts (updated - added chunking functionality)

### Notes for next developer:
- For long PDFs, use `generateSummaryWithChunking()` instead of `generateSummary()`
- Import: `import { generateSummaryWithChunking, chunkText, estimateTokens, ChunkProgressCallback } from '@/lib/openrouter'`
- The progress callback receives (current, total) for showing "Elaborando parte X di Y"
- If combined summaries are small enough (< 1.5x maxTokens), they're returned directly without AI combining
- If AI combining fails, concatenated summaries are returned with dividers as fallback
- Next priority is US-012: API route per generazione riassunto

---

## 2026-01-25 - US-012: API route per generazione riassunto

### What was done:
- Created app/api/summarize/route.ts with POST endpoint
- Accepts FormData with:
  - file: PDF file (required, max 20MB)
  - excludePages: string with page ranges (optional, e.g., "1-3, 5")
  - detailLevel: "brief" | "medium" | "detailed" (required)
- Validates file type (application/pdf or .pdf extension)
- Validates file size (max 20MB)
- Validates detail level against allowed values
- Parses excludePages using parsePageRanges from lib/utils.ts
- Extracts text from PDF using extractText from lib/pdf-parser
- Generates summary using generateSummaryWithChunking from lib/openrouter
- Saves Summary to database with Prisma (user_id null for guest users)
- Returns JSON response: { summaryId: string, content: string }
- Proper error handling with user-friendly Italian error messages
- Typecheck passes successfully

### Files created/modified:
- app/api/summarize/route.ts (new - API endpoint for PDF summarization)

### Notes for next developer:
- The API uses FormData for file upload, not JSON
- To call this API from the frontend, use `new FormData()` and append file, excludePages, detailLevel
- Example: `formData.append('file', pdfFile); formData.append('detailLevel', 'medium');`
- The summaryId can be used to navigate to /summary/[id] page (US-013)
- User authentication will be added in US-024 to associate summaries with logged-in users
- Next priority is US-013: Pagina risultato riassunto

---

## 2026-01-25 - US-013: Pagina risultato riassunto

### What was done:
- Created /summary/[id] dynamic route page for displaying generated summaries
- Installed react-markdown for Markdown rendering
- Server component (page.tsx) fetches summary from database using Prisma
- Shows 404 if summary not found using Next.js notFound()
- Displays summary metadata: PDF title, detail level (with Italian labels), creation date
- Client component (summary-content.tsx) handles Markdown rendering with custom styled components:
  - Headings (h1, h2, h3) with proper spacing and colors
  - Paragraphs with relaxed line height
  - Ordered and unordered lists with bullet/number styling
  - Bold and italic text with appropriate colors
  - Blockquotes with blue left border and background
  - Inline and block code with monospace font
  - Horizontal rules
- "Genera Quiz" button links to /quiz/generate/[summaryId] (quiz generation in US-016)
- "Scarica PDF" button with placeholder (full implementation in US-019)
- Responsive design with mobile-first approach
- Dark mode support throughout
- Typecheck passes successfully

### Files created/modified:
- package.json (added react-markdown dependency)
- app/summary/[id]/page.tsx (new - server component for summary page)
- app/summary/[id]/summary-content.tsx (new - client component for Markdown rendering and actions)

### Notes for next developer:
- The summary page uses server components for data fetching, client components for interactivity
- ReactMarkdown is used with custom component overrides for consistent styling
- The "Scarica PDF" button shows an alert - full PDF generation will be implemented in US-019
- The "Genera Quiz" button links to a route that doesn't exist yet (/quiz/generate/[id]) - that's US-016
- Detail level labels are mapped from English (brief/medium/detailed) to Italian (Breve/Medio/Dettagliato)
- Next priority is US-014: Progress indicator durante generazione

---

## 2026-01-25 - US-014: Progress indicator durante generazione

### What was done:
- Created ProgressIndicator component in components/progress-indicator.tsx
- Component supports 4 stages: analyzing, generating, chunking, saving
- Each stage has a main message and a description in Italian
- Features implemented:
  - Spinner with pulsing background animation for visual feedback
  - Different messages for each stage ("Analizzando il PDF...", "Generando riassunto...", etc.)
  - For chunking stage: shows "Elaborando parte X di Y..." with a progress bar
  - Progress bar with percentage indicator
  - Helpful tip box explaining not to close the page
- Updated /upload page to integrate the progress indicator:
  - Shows ProgressIndicator when isProcessing is true
  - Form is hidden during processing for clean UI
  - Stage transitions: analyzing (1.5s) -> generating -> saving -> redirect
  - API error handling with styled error message display
  - Connected "Genera Riassunto" button to handleSubmit function
- Full API integration: creates FormData, calls /api/summarize, redirects to /summary/[id]
- Smooth animations using Tailwind CSS transition classes
- Typecheck passes successfully

### Files created/modified:
- components/progress-indicator.tsx (new - ProgressIndicator component with stage support)
- app/upload/page.tsx (updated - added processing state, API call, progress indicator integration)

### Notes for next developer:
- Import the component: `import { ProgressIndicator, ProgressStage } from '@/components/progress-indicator'`
- ProgressStage type is "analyzing" | "generating" | "chunking" | "saving"
- The chunking stage supports a progress object: `{ current: number, total: number }`
- The actual chunking progress from OpenRouter isn't streamed to the client (would require SSE/WebSocket)
- For now, client simulates stage transitions; server-side streaming could be added later
- Error messages from the API are displayed with a styled red error box
- The page automatically redirects to /summary/[summaryId] on success
- Next priority is US-015: Servizio generazione quiz

---

## 2026-01-25 - US-015: Servizio generazione quiz

### What was done:
- Added quiz generation functionality to lib/openrouter.ts
- Created `generateQuiz(summaryContent)` function that generates 10 quiz questions
- Quiz composition: ~7 multiple choice questions (4 options each) and ~3 true/false questions
- Defined TypeScript types:
  - `QuizQuestionType` = 'multiple_choice' | 'true_false'
  - `QuizQuestion` interface with question, type, options?, correctAnswer, explanation
- Italian system prompt requests questions in the same language as the content
- Features implemented:
  - `getQuizSystemPrompt()` - Detailed Italian prompt with JSON format specification
  - `getQuizUserPrompt()` - User prompt with summary content
  - `parseQuizResponse()` - Robust JSON parsing with:
    - Markdown code block removal (```json ... ```)
    - Array extraction from response text
    - Question validation and normalization
    - True/false answer normalization (handles Vero/Falso/True/False/V/F)
    - Multiple choice option matching for correctAnswer
- Integrated API key failover: retries on 401/429/402 errors with different keys
- Special handling: marks key success on parse errors (API worked), still retries for better JSON
- Typecheck passes successfully

### Files created/modified:
- lib/openrouter.ts (updated - added quiz generation functionality)

### Notes for next developer:
- Import quiz function: `import { generateQuiz, QuizQuestion, QuizQuestionType } from '@/lib/openrouter'`
- The function is async and returns `Promise<QuizQuestion[]>`
- For multiple_choice questions: `options` array has 4 strings, `correctAnswer` matches one exactly
- For true_false questions: `correctAnswer` is "Vero" or "Falso", no `options` field
- Each question has an `explanation` field explaining why the answer is correct
- The parser handles markdown code blocks and extra text from AI responses
- Next priority is US-016: API route per generazione quiz

---

## 2026-01-25 - US-016: API route per generazione quiz

### What was done:
- Created app/api/quiz/route.ts with POST endpoint for quiz generation
- Endpoint accepts JSON body with summaryId parameter
- Fetches summary from database using Prisma
- Validates summary exists and has sufficient content (minimum 100 characters)
- Calls generateQuiz() from lib/openrouter.ts to generate quiz questions
- Saves Quiz to database with questions stored as JSON string
- Returns JSON response with quizId and questions array
- Proper error handling with Italian user-friendly messages:
  - 400: Invalid request (missing summaryId, content too short)
  - 404: Summary not found
  - 500: OpenRouter API errors or internal server errors
- Typecheck passes successfully

### Files created/modified:
- app/api/quiz/route.ts (new - API endpoint for quiz generation)

### Notes for next developer:
- Call the API: `POST /api/quiz` with JSON body `{ "summaryId": "..." }`
- Response format: `{ quizId: string, questions: QuizQuestion[] }`
- The questions array contains 10 questions (~7 multiple choice, ~3 true/false)
- Quiz is stored in database linked to the summary via summary_id foreign key
- The endpoint can be called from the "Genera Quiz" button on /summary/[id] page
- Next priority is US-017: Interfaccia quiz interattivo

---

## 2026-01-25 - US-017: Interfaccia quiz interattivo

### What was done:
- Created /quiz/generate/[summaryId] page that calls the quiz API and redirects
  - Shows loading spinner with "Generando il Quiz..." message
  - Error handling with retry option
  - Redirects to /quiz/[quizId] on success
- Created /quiz/[id] page with interactive quiz interface
  - Server component (page.tsx) fetches quiz and summary data from database
  - Client component (quiz-interface.tsx) handles all interactive state
- Quiz interface features:
  - One question at a time with question number (1/10)
  - Progress bar showing current position
  - Question type badge (Scelta multipla / Vero/Falso)
  - Multiple choice: 4 option buttons with A/B/C/D letter labels
  - True/False: Vero/Falso buttons with checkmark/X icons
  - Visual highlighting of selected answer (blue for MC, green for Vero, red for Falso)
  - Navigation buttons: Indietro (back) and Avanti (next)
  - Dot navigation at bottom to jump between questions
  - Answered questions shown with green dots
  - "Verifica Risposte" button appears on last question (disabled until all questions answered)
- Responsive design with mobile-first approach
- Dark mode support throughout
- Typecheck passes successfully

### Files created/modified:
- app/quiz/generate/[summaryId]/page.tsx (new - quiz generation page)
- app/quiz/[id]/page.tsx (new - quiz page server component)
- app/quiz/[id]/quiz-interface.tsx (new - quiz interface client component)

### Notes for next developer:
- The "Genera Quiz" button on /summary/[id] now works - it navigates to /quiz/generate/[summaryId]
- Quiz answers are passed to results page via URL query parameter (JSON encoded)
- The results page (/quiz/[id]/results) is not yet implemented - that's US-018
- QuizQuestion type is imported from '@/lib/openrouter'
- Answer state is stored as (string | null)[] array matching questions array
- Next priority is US-018: Schermata risultati quiz

---

## 2026-01-25 - US-018: Schermata risultati quiz

### What was done:
- Created /quiz/[id]/results page with server and client components
- Server component (page.tsx) handles:
  - Fetching quiz and summary data from database
  - Parsing user answers from URL query parameter
  - Validating answers array matches questions length
  - 404 handling for non-existent quiz
- Client component (quiz-results.tsx) displays:
  - Score card with X/10 format and percentage
  - Color-coded feedback based on performance:
    - Green (>=80%): "Ottimo lavoro!"
    - Yellow (>=60%): "Buon risultato!"
    - Red (<60%): "Continua a studiare!"
  - Question list with green/red left border indicators
  - Checkmark/X icons for correct/incorrect answers
  - Question type badges (Scelta multipla / Vero / Falso)
  - User's answer shown for each question
  - Correct answer and explanation shown only for incorrect answers
  - Explanation in styled info box with icon
- Action buttons:
  - "Ripeti Quiz" button links back to /quiz/[id] to retake quiz
  - "Torna al Riassunto" button links to /summary/[summaryId]
- Responsive design with mobile-first approach
- Dark mode support throughout
- Typecheck passes successfully

### Files created/modified:
- app/quiz/[id]/results/page.tsx (new - server component for results page)
- app/quiz/[id]/results/quiz-results.tsx (new - client component for results display)

### Notes for next developer:
- Answers are passed via URL query parameter `?answers=` as JSON-encoded array
- Results are calculated client-side by comparing user answers with correctAnswer from questions
- The "Ripeti Quiz" button resets the quiz by navigating to the quiz page (answers start fresh)
- Explanations are only shown for incorrect answers to focus user attention on learning
- Score percentage determines the motivational message and color scheme
- Next priority is US-019: Download riassunto come PDF

---

## 2026-01-25 - US-019: Download riassunto come PDF

### What was done:
- Installed jspdf for client-side PDF generation
- Created lib/pdf-generator.ts with PDF generation utility
- Implemented generateSummaryPdf() function that:
  - Converts Markdown to plain text with formatting preserved
  - Creates A4 portrait PDF with proper margins
  - Includes title, file name, detail level (Italian), and date
  - Formats content with headers (bold) and bullet points
  - Handles page breaks automatically
  - Adds footer with page numbers ("Generato con Riassu.mi - Pagina X di Y")
- Updated summary-content.tsx to call generateSummaryPdf on button click
- Updated page.tsx to pass additional props (pdfName, detailLevel, createdAt)
- File naming: riassunto-[sanitized-title]-[date].pdf
- Typecheck passes successfully

### Files created/modified:
- package.json (added jspdf dependency)
- lib/pdf-generator.ts (new - PDF generation utility)
- app/summary/[id]/summary-content.tsx (updated - connected download button)
- app/summary/[id]/page.tsx (updated - added props for PDF metadata)

### Notes for next developer:
- Import PDF generator: `import { generateSummaryPdf } from '@/lib/pdf-generator'`
- The function takes SummaryPdfData object with title, pdfName, detailLevel, createdAt, content
- Markdown is converted to plain text - complex formatting is simplified
- PDF uses Helvetica font (built into jsPDF, no external fonts needed)
- The sanitized filename removes special characters and limits to 50 chars
- Next priority is US-020: Download quiz come PDF

---

## 2026-01-25 - US-020: Download quiz come PDF

### What was done:
- Added generateQuizPdf() function to lib/pdf-generator.ts
- PDF structure:
  - Title "Quiz di Verifica" with summary title subtitle
  - Creation date
  - Numbered questions with type indicator (Scelta multipla / Vero/Falso)
  - Multiple choice questions show A/B/C/D option labels
  - True/False questions show "○ Vero    ○ Falso" options
  - Answers section on separate page at end of document
  - Each answer shows correct response and explanation (in italic)
  - Footer on all pages: "Generato con Riassu.mi - Pagina X di Y"
- File naming: quiz-[sanitized-title]-[date].pdf
- Added "Scarica Quiz" button with download icon to quiz results page
- Updated QuizResults component to accept createdAt prop
- Updated server component to pass quiz.created_at to client component
- Typecheck passes successfully

### Files created/modified:
- lib/pdf-generator.ts (updated - added generateQuizPdf function and QuizPdfData interface)
- app/quiz/[id]/results/quiz-results.tsx (updated - added download button and handler)
- app/quiz/[id]/results/page.tsx (updated - passes createdAt prop)

### Notes for next developer:
- Import quiz PDF generator: `import { generateQuizPdf } from '@/lib/pdf-generator'`
- The function takes QuizPdfData object with title, createdAt, questions (QuizQuestion[])
- The answers section is always on a new page for easy separate printing
- Questions have estimated height check for page breaks
- Both summary and quiz PDF generators share the same file
- Next priority is US-021: Form registrazione utente

---

## 2026-01-25 - US-021: Form registrazione utente

### What was done:
- Installed bcrypt for secure password hashing
- Created API route at app/api/auth/register/route.ts with:
  - Email format validation using regex
  - Password length validation (minimum 8 characters)
  - Duplicate email check with 409 Conflict response
  - Password hashing with bcrypt (10 rounds)
  - User creation in database with Prisma
  - Italian error messages for all validation failures
- Created /register page with registration form:
  - Three input fields: email, password, confirm password
  - Client-side validation before form submission
  - Real-time error clearing when user corrects input
  - Loading state with spinner during API call
  - Error display for API errors
  - Redirect to /login?registered=true on success
- Form validation includes:
  - Email: required, valid format
  - Password: required, minimum 8 characters
  - Confirm Password: required, must match password
- Responsive design with mobile-first approach
- Dark mode support throughout
- Typecheck passes successfully

### Files created/modified:
- package.json (added bcrypt, @types/bcrypt dependencies)
- app/api/auth/register/route.ts (new - registration API endpoint)
- app/register/page.tsx (new - registration form page)

### Notes for next developer:
- The registration form redirects to /login?registered=true which can show a success message (once login page is created)
- Email is stored in lowercase for consistency
- bcrypt with 10 rounds provides good security/performance balance
- The API uses 409 Conflict status for duplicate email (standard HTTP code)
- The login page (/login) referenced in the form link doesn't exist yet - that's US-022
- Next priority is US-022: Form login e gestione sessione

---

## 2026-01-25 - US-022: Form login e gestione sessione

### What was done:
- Created lib/auth.ts with complete session management functionality:
  - `createSessionToken(userId)` - Creates signed token with user ID and timestamp
  - `verifySessionToken(token)` - Verifies signature and expiry using timing-safe comparison
  - `getSession()` - Returns current user from session cookie or null
  - `createSession(userId)` - Sets HTTP-only cookie after login
  - `destroySession()` - Clears session cookie for logout
- Session uses HMAC-SHA256 signing with SESSION_SECRET or ENCRYPTION_KEY from env
- Session cookie properties: HTTP-only, Secure in production, SameSite=lax, 7 days expiry
- Created API route at app/api/auth/login/route.ts:
  - Validates required fields (email, password)
  - Finds user by lowercase email
  - Verifies password with bcrypt.compare()
  - Returns generic "Credenziali non valide" error (prevents email enumeration)
  - Creates session on successful login
  - Returns user info on success
- Created /login page with login form:
  - Email and password fields with validation
  - Client-side validation before API call
  - Loading state with spinner during submission
  - Error display for API errors
  - Success message for users coming from registration (?registered=true)
  - Auto-hides registration message after 5 seconds
  - Redirect to /dashboard on successful login
  - Link to registration page for new users
- Responsive design with mobile-first approach
- Dark mode support throughout
- Typecheck passes successfully

### Files created/modified:
- lib/auth.ts (new - session management with signed cookies)
- app/api/auth/login/route.ts (new - login API endpoint)
- app/login/page.tsx (new - login form page)

### Notes for next developer:
- Import session functions: `import { getSession, createSession, destroySession } from '@/lib/auth'`
- `getSession()` returns `{ id: string, email: string }` or `null`
- Session token format: `userId:timestamp:signature` (HMAC-SHA256)
- The /dashboard page doesn't exist yet - that's US-025
- Middleware for protecting routes will be implemented in US-023
- SESSION_SECRET can be added to .env for a separate session key, or it will use ENCRYPTION_KEY
- Next priority is US-023: Middleware autenticazione

---

## 2026-01-25 - US-023: Middleware autenticazione

### What was done:
- Created middleware.ts at project root for Next.js Edge runtime
- Implemented Edge-compatible session verification using Web Crypto API:
  - `verifySessionToken()` uses `crypto.subtle` for HMAC-SHA256 (not Node.js crypto)
  - Constant-time comparison to prevent timing attacks
  - Token expiry validation (7 days)
- Protected routes configuration:
  - PROTECTED_ROUTES: ["/dashboard"] - require authentication
  - PUBLIC_ROUTES: ["/", "/upload", "/login", "/register", "/summary", "/quiz"] - accessible to all
- Middleware behavior:
  - Skips static files, API routes, and assets
  - Redirects to /login with `?redirect=` query param if accessing protected route without session
  - Clears invalid/expired session cookies automatically
  - Allows valid sessions to proceed
- Uses SESSION_SECRET or ENCRYPTION_KEY from environment for signing
- Typecheck passes successfully

### Files created/modified:
- middleware.ts (new - Next.js Edge middleware for route protection)

### Notes for next developer:
- The middleware runs on Edge runtime, so it uses Web Crypto API instead of Node.js crypto
- Database lookups are NOT performed in middleware (Edge can't use Prisma with SQLite)
- Token signature verification is sufficient for route protection; actual user lookup happens in server components
- To add more protected routes, add them to the PROTECTED_ROUTES array
- The `?redirect=` query param can be used by /login to redirect back after successful auth
- getSession() from lib/auth.ts should still be used in server components for actual user data
- Next priority is US-024: Associare riassunti all'utente loggato

---

## 2026-01-25 - US-024: Associare riassunti all'utente loggato

### What was done:
- Modified app/api/summarize/route.ts to associate summaries with logged-in users
- Added import for getSession from '@/lib/auth'
- API now calls getSession() to retrieve the current user session
- If user is logged in (session exists): user_id is set to session.id
- If guest (no session): user_id remains null
- Used nullish coalescing operator (session?.id ?? null) for clean null handling
- Typecheck passes successfully

### Files created/modified:
- app/api/summarize/route.ts (updated - added getSession import and user_id association)

### Notes for next developer:
- Summaries created by logged-in users will now appear in their dashboard (once US-025 is implemented)
- Guest users can still create summaries, but they won't be saved to any user account
- The getSession() function handles all session validation including signature verification and expiry
- No changes needed to the frontend - authentication is transparent to the user
- Next priority is US-025: Dashboard utente con storico

---

## 2026-01-25 - US-025: Dashboard utente con storico

### What was done:
- Created /dashboard page at app/dashboard/page.tsx
- Server component that fetches user summaries using getSession() for authentication
- Redirects to /login if not authenticated (with redirect query param)
- Fetches summaries filtered by user_id, ordered by created_at descending
- Displays summary cards with:
  - Title (links to /summary/[id])
  - PDF filename with document icon
  - Detail level with Italian labels (Breve/Medio/Dettagliato)
  - Creation date formatted in Italian locale
  - Arrow icon indicating clickability
- Empty state when no summaries exist:
  - Large document icon
  - "Nessun riassunto" heading
  - Descriptive text encouraging first upload
  - CTA button to upload first PDF
- "Carica nuovo PDF" button at top of page
- Responsive design with mobile-first approach
- Dark mode support throughout
- Typecheck passes successfully

### Files created/modified:
- app/dashboard/page.tsx (new - dashboard page with summary list)

### Notes for next developer:
- The dashboard is already protected by middleware.ts (set up in US-023)
- Uses the same card design pattern as /summary/[id] page for consistency
- The detailLevelLabels mapping is duplicated from /summary/[id]/page.tsx - could be extracted to a shared utility if more pages need it
- Currently uses only SELECT for efficiency (only fetches needed fields, not full content)
- Next priority is US-026: Eliminazione riassunto

---

## 2026-01-25 - US-026: Eliminazione riassunto

### What was done:
- Created DELETE API route at app/api/summary/[id]/route.ts
- API endpoint verifies:
  - User is authenticated (401 if not)
  - Summary exists (404 if not)
  - User owns the summary (403 if not)
- Deletes summary and associated quizzes (cascade delete via Prisma schema)
- Created SummaryList client component at app/dashboard/summary-list.tsx
- Features implemented:
  - Delete button (trash icon) on each summary card
  - Positioned to the right, doesn't interfere with card navigation
  - Hover effect shows red color on the delete button
  - Confirmation modal with warning icon
  - Modal text: "Questa azione eliminerà anche il quiz associato e non può essere annullata."
  - Loading state during deletion with spinner
  - Error display in modal if deletion fails
  - List updates immediately after successful deletion
  - Calls router.refresh() to sync server-side data
- Updated dashboard page to use the new SummaryList component
- Responsive design with dark mode support
- Typecheck passes successfully

### Files created/modified:
- app/api/summary/[id]/route.ts (new - DELETE endpoint for summary deletion)
- app/dashboard/summary-list.tsx (new - client component with delete functionality)
- app/dashboard/page.tsx (updated - uses SummaryList component)

### Notes for next developer:
- The SummaryList component manages local state for optimistic UI updates
- Modal uses fixed positioning with z-50 to overlay the page
- Delete button uses e.preventDefault() and e.stopPropagation() to prevent Link navigation
- Error messages from API are displayed in the modal
- Next priority is US-027: Header con navigazione e stato auth

---

## 2026-01-26 - US-027: Header con navigazione e stato auth

### What was done:
- Created components/header.tsx with responsive navigation
- Header displays logo "Riassu.mi" that links to homepage
- For guests: shows "Accedi" and "Registrati" buttons
- For logged-in users: shows "Dashboard" link and "Esci" button
- Created HeaderWrapper server component (components/header-wrapper.tsx) to fetch session data
- Created logout API endpoint at app/api/auth/logout/route.ts
  - Calls destroySession() from lib/auth.ts to clear the session cookie
  - Returns JSON success response
- Added HeaderWrapper to app/layout.tsx so header appears on all pages
- Updated homepage (app/page.tsx) to adjust height calculation for header
- Changed html lang attribute from "en" to "it" for Italian language
- Logout button shows loading state during logout process
- Responsive design with dark mode support
- Typecheck passes successfully

### Files created/modified:
- components/header.tsx (new - client component for navigation header)
- components/header-wrapper.tsx (new - server component wrapper to fetch session)
- app/api/auth/logout/route.ts (new - logout API endpoint)
- app/layout.tsx (updated - added HeaderWrapper, changed lang to "it")
- app/page.tsx (updated - adjusted height calculation for header)

### Notes for next developer:
- Header uses HeaderWrapper pattern: server component fetches session, passes to client component
- Logout redirects to "/" and calls router.refresh() to update header state
- The header height is approximately 73px (py-4 + content); pages should use min-h-[calc(100vh-73px)] if they want full height
- The Button component from @/components/ui is used for consistent styling
- Next priority is US-028: Pagina admin gestione API key

---

## 2026-01-26 - US-028: Pagina admin gestione API key

### What was done:
- Created /admin/api-keys page for managing OpenRouter API keys
- Page is protected by ADMIN_EMAIL environment variable
- Server component (page.tsx) verifies:
  - ADMIN_EMAIL is configured (shows config error if not)
  - User is authenticated (redirects to login if not)
  - User email matches ADMIN_EMAIL (shows access denied if not)
- Created API routes:
  - GET /api/admin/api-keys - Lists all API keys with masked values
  - POST /api/admin/api-keys - Adds new API key
  - DELETE /api/admin/api-keys/[id] - Permanently deletes an API key
  - PATCH /api/admin/api-keys/[id] - Reactivates or deactivates an API key
- Client component (api-key-list.tsx) features:
  - Add new key form with password input type for security
  - List of keys showing: last 4 chars, status badge, provider, fail_count, last_used, disabled_until
  - Status badges: Attiva (green), Disattivata (gray), Temp. disabilitata (orange)
  - Reactivate/Deactivate toggle button for each key
  - Delete button with confirmation modal
  - Loading states and error handling throughout
- Updated middleware.ts to protect /admin routes
- Added ADMIN_EMAIL to .env as commented example
- Responsive design with dark mode support
- Typecheck passes successfully

### Files created/modified:
- app/admin/api-keys/page.tsx (new - admin page server component)
- app/admin/api-keys/api-key-list.tsx (new - API key list client component)
- app/api/admin/api-keys/route.ts (new - GET/POST endpoints for API keys)
- app/api/admin/api-keys/[id]/route.ts (new - DELETE/PATCH endpoints for individual keys)
- middleware.ts (updated - added /admin to protected routes)
- .env (updated - added ADMIN_EMAIL example)
- prd.json (updated - marked US-028 as passes: true)

### Notes for next developer:
- To access the admin page, set ADMIN_EMAIL in .env to match a registered user's email
- The page decrypts keys server-side to show last 4 characters (never exposes full key)
- API routes use the same admin verification pattern as the page
- Keys can be temporarily disabled (auto by failover system) or permanently deactivated
- Reactivating a key resets fail_count and clears disabled_until
- Next priority is US-029: Toast notifications
